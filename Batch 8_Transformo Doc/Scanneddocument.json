{"content": "This script is designed to extract text from PDF and DOCX files, performing\nOptical Character Recognition (OCR) on scanned PDFs if necessary. The ex-\ntracted text is then saved in a machine-readable JSON format. The script uses\nthe following libraries:\n\u2022 easyocr: For performing OCR on images.\n\u2022 pdfplumber: For extracting text from PDF files.\n\u2022 docx2txt: For extracting text from DOCX files.\n\u2022 numpy: For handling image data in array format.\n\u2022 PIL (Python Imaging Library): For image processing.\n\u2022 colorama: For colored terminal output.\nCode Breakdown\nImports and Initialization\nimport easyocr\nimport pdfplumber\nimport docx2txt\nimport os\nimport json\nimport numpy as np\nfrom PIL import Image\nfrom colorama import Fore, Style, init\n# Initialize colorama for colored output\ninit(autoreset=True)\n# Create an EasyOCR Reader instance\nreader = easyocr.Reader(['en']) # Specify languages (e.g., 'en' for English)\n\u2022 The required libraries are imported.\n\u2022 colorama is initialized for colored terminal outputs to make log messages\nmore readable.\n\u2022 An instance of the EasyOCR reader is created, specifying English as the\nlanguage for text recognition.\nFunction: is_machine_readable\ndef is_machine_readable(filepath):\n\"\"\" Check if the document is already machine-readable by its extension. \"\"\"\n_, ext = os.path.splitext(filepath)\nreturn ext.lower() in ['.txt', '.json']\n\u2022 Purpose: Determine if the document is already in a machine-readable\nformat based on its file extension.\n\u2022 Parameters:\n\u2013 filepath: The path to the document file.\n1\n\u2022 Returns: True if the file is a .txt or .json, False otherwise.\nFunction: extract_text_from_pdf\ndef extract_text_from_pdf(filepath):\n\"\"\" Extract text from a PDF document using pdfplumber. \"\"\"\ntext = \"\"\nprint(f\"{Fore.BLUE}Extracting text from PDF: {filepath}\")\nwith pdfplumber.open(filepath) as pdf:\nfor i, page in enumerate(pdf.pages):\npage_text = page.extract_text()\nif page_text:\nprint(f\"{Fore.GREEN}Extracted text from page {i + 1} using pdfplumber.\")\ntext += page_text + \"\\n\"\nelse:\nprint(f\"{Fore.YELLOW}No text found on page {i + 1}. Performing OCR...\")\n# If no text is found, apply OCR to the page image\nimage = page.to_image(resolution=300)\nocr_text = ocr_image(image.original)\ntext += ocr_text + \"\\n\"\nreturn text\n\u2022 Purpose: Extract text from a PDF file. If a page does not contain text,\nit uses OCR to extract text from the page image.\n\u2022 Parameters:\n\u2013 filepath: The path to the PDF file.\n\u2022 Returns: A string containing all the extracted text from the PDF.\nFunction: ocr_image\ndef ocr_image(image):\n\"\"\" Perform OCR on a given image using EasyOCR. \"\"\"\n# Convert the image to a NumPy array for EasyOCR\nimage_np = np.array(image)\nresult = reader.readtext(image_np)\nreturn \" \".join([res[1] for res in result])\n\u2022 Purpose: Perform OCR on a given image to extract text.\n\u2022 Parameters:\n\u2013 image: A PIL Image object.\n\u2022 Returns: A string containing the extracted text from the image.\nFunction: extract_text_from_docx\ndef extract_text_from_docx(filepath):\n\"\"\" Extract all text content from a DOCX file. \"\"\"\n2\nprint(f\"{Fore.YELLOW}Extracting text from DOCX: {filepath}\")\ntext = docx2txt.process(filepath)\nprint(f\"{Fore.GREEN}Text extraction from DOCX complete.\")\nreturn text\n\u2022 Purpose: Extract text from a DOCX file.\n\u2022 Parameters:\n\u2013 filepath: The path to the DOCX file.\n\u2022 Returns: A string containing all the extracted text from the DOCX file.\nFunction: transform_to_machine_readable\ndef transform_to_machine_readable(filepath):\n\"\"\" Transforms non-machine-readable documents into a JSON format. \"\"\"\n_, ext = os.path.splitext(filepath)\nprint(f\"{Fore.BLUE}Starting transformation of {filepath} to machine-readable format...\")\nif ext.lower() == '.pdf':\ntext = extract_text_from_pdf(filepath)\nelif ext.lower() == '.docx':\ntext = extract_text_from_docx(filepath)\nelse:\nraise ValueError(f\"{Fore.RED}Unsupported file type for OCR: {ext}\")\n# Structure extracted text into JSON\ndata = {\"content\": text}\njson_output = filepath.replace(ext, \".json\")\nwith open(json_output, 'w') as f:\njson.dump(data, f)\nprint(f\"{Fore.CYAN}Transformed and saved as JSON: {json_output}\")\nreturn json_output\n\u2022 Purpose: Convert non-machine-readable documents (PDFs or DOCX)\ninto a machine-readable JSON format.\n\u2022 Parameters:\n\u2013 filepath: The path to the document file.\n\u2022 Returns: The path of the created JSON file.\nFunction: process_document\ndef process_document(filepath):\n\"\"\" Primary function to process documents based on their readability status. \"\"\"\nprint(f\"{Fore.MAGENTA}Processing document: {filepath}\")\nif is_machine_readable(filepath):\nprint(f\"{Fore.GREEN}{filepath} is already machine-readable.\")\n3\nelif os.path.splitext(filepath)[1].lower() in ['.pdf', '.docx']:\nprint(f\"{Fore.RED}{filepath} is not machine-readable. Transforming...\")\ntransform_to_machine_readable(filepath)\nelse:\nprint(f\"{Fore.RED}Unsupported file type: {filepath}\")\n\u2022 Purpose: Mainfunctiontodeterminewhetheradocumentneedsprocess-\ning or if it is already in a machine-readable format.\n\u2022 Parameters:\n\u2013 filepath: The path to the document file.\n\u2022 Functionality: Calls other functions to handle the document based on\nits current format.\nExample Usage\n# Example usage - replace with actual document path\nfile_path = r\"document_87ab3de3-dd28-476f-aab2-5967245f8e88 (2)-6-8.pdf\" # Update with your document path\nprocess_document(file_path)\n\u2022 This part of the code demonstrates how to use the process_document\nfunction with a specified file path. Update the file_path variable to\npoint to your desired PDF or DOCX document.\nConclusion\nThisscriptautomatestheextractionoftextfromPDFandDOCXfiles,convert-\ning them into a machine-readable format. It is particularly useful for dealing\nwith scanned documents where OCR is needed. Beginners can build upon this\nfoundation by adding more features or improving the error handling as they\nbecome more familiar with Python and these libraries.\n4\n"}